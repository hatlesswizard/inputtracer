// Package main - generator.go generates Go source files from parsed methods
package main

import (
	"fmt"
	"strings"
	"time"
)

// Generator produces Go source code for framework patterns
type Generator struct{}

// NewGenerator creates a new code generator
func NewGenerator() *Generator {
	return &Generator{}
}

// GenerateLaravel generates laravel.go content
func (g *Generator) GenerateLaravel(methods []ParsedMethod, fw *FrameworkDefinition) string {
	var b strings.Builder

	g.writeHeader(&b, fw, "https://github.com/illuminate/http")
	g.writePackage(&b)
	g.writeImport(&b)

	b.WriteString("var laravelPatterns = []*common.FrameworkPattern{\n")

	for _, m := range methods {
		sourceType := InferSourceType(m.Name)
		populatedFrom := InferPopulatedFrom(sourceType)
		description := InferDescription(fw.Name, m.Name, false, sourceType)
		g.writePatternInferred(&b, fw, m, sourceType, populatedFrom, description)
	}

	b.WriteString("}\n\n")
	g.writeInit(&b, "laravel", fw)

	return b.String()
}

// GenerateSymfony generates symfony.go content
func (g *Generator) GenerateSymfony(methods []ParsedMethod, properties []ParsedMethod, fw *FrameworkDefinition) string {
	var b strings.Builder

	g.writeHeader(&b, fw, "https://github.com/symfony/http-foundation")
	g.writePackage(&b)
	g.writeImport(&b)

	b.WriteString("var symfonyPatterns = []*common.FrameworkPattern{\n")

	// Properties still use explicit mapping
	for _, p := range properties {
		mapping := SymfonyPropertyMappings[p.Name]
		if mapping == nil {
			continue
		}
		g.writePropertyPattern(&b, fw, p, mapping)
	}

	// Methods use inference
	for _, m := range methods {
		sourceType := InferSourceType(m.Name)
		populatedFrom := InferPopulatedFrom(sourceType)
		description := InferDescription(fw.Name, m.Name, false, sourceType)
		g.writeSymfonyMethodPatternInferred(&b, fw, m, sourceType, populatedFrom, description)
	}

	b.WriteString("}\n\n")
	g.writeInit(&b, "symfony", fw)

	return b.String()
}

func (g *Generator) writeHeader(b *strings.Builder, fw *FrameworkDefinition, sourceURL string) {
	b.WriteString("// Code generated by genpatterns. DO NOT EDIT.\n")
	b.WriteString("// Source: " + sourceURL + "\n")
	b.WriteString("// Generated: " + time.Now().Format("2006-01-02") + "\n\n")
}

func (g *Generator) writePackage(b *strings.Builder) {
	b.WriteString("package php\n\n")
}

func (g *Generator) writeImport(b *strings.Builder) {
	b.WriteString("import (\n")
	b.WriteString("\t\"github.com/hatlesswizard/inputtracer/pkg/sources/common\"\n")
	b.WriteString(")\n\n")
}

func (g *Generator) writePropertyPattern(b *strings.Builder, fw *FrameworkDefinition, p ParsedMethod, mapping *MethodMapping) {
	id := fmt.Sprintf("%s_request_%s", fw.Name, p.Name)
	name := fmt.Sprintf("%s $request->%s", strings.Title(fw.Name), p.Name)

	b.WriteString("\t{\n")
	b.WriteString(fmt.Sprintf("\t\tID:              %q,\n", id))
	b.WriteString(fmt.Sprintf("\t\tFramework:       %q,\n", fw.Name))
	b.WriteString(fmt.Sprintf("\t\tLanguage:        %q,\n", fw.Language))
	b.WriteString(fmt.Sprintf("\t\tName:            %q,\n", name))
	b.WriteString(fmt.Sprintf("\t\tDescription:     %q,\n", mapping.Description))
	b.WriteString(fmt.Sprintf("\t\tClassPattern:    %q,\n", fw.ClassPattern))
	b.WriteString(fmt.Sprintf("\t\tPropertyPattern: \"^%s$\",\n", p.Name))
	b.WriteString(fmt.Sprintf("\t\tSourceType:      common.%s,\n", mapping.SourceType))
	b.WriteString(fmt.Sprintf("\t\tCarrierClass:    %q,\n", fw.CarrierClass))
	b.WriteString(fmt.Sprintf("\t\tCarrierProperty: %q,\n", p.Name))
	if len(mapping.PopulatedFrom) > 0 {
		b.WriteString(fmt.Sprintf("\t\tPopulatedFrom:   []string{%s},\n", g.formatStringSlice(mapping.PopulatedFrom)))
	}
	b.WriteString(fmt.Sprintf("\t\tTags:            []string{%s},\n", g.formatStringSlice(fw.Tags)))
	b.WriteString("\t},\n")
}

func (g *Generator) writePatternInferred(b *strings.Builder, fw *FrameworkDefinition, m ParsedMethod, sourceType string, populatedFrom []string, description string) {
	id := fmt.Sprintf("%s_request_%s", fw.Name, m.Name)
	name := fmt.Sprintf("%s $request->%s()", strings.Title(fw.Name), m.Name)

	b.WriteString("\t{\n")
	b.WriteString(fmt.Sprintf("\t\tID:            %q,\n", id))
	b.WriteString(fmt.Sprintf("\t\tFramework:     %q,\n", fw.Name))
	b.WriteString(fmt.Sprintf("\t\tLanguage:      %q,\n", fw.Language))
	b.WriteString(fmt.Sprintf("\t\tName:          %q,\n", name))
	b.WriteString(fmt.Sprintf("\t\tDescription:   %q,\n", description))
	b.WriteString(fmt.Sprintf("\t\tClassPattern:  %q,\n", fw.ClassPattern))
	b.WriteString(fmt.Sprintf("\t\tMethodPattern: \"^%s$\",\n", m.Name))
	b.WriteString(fmt.Sprintf("\t\tSourceType:    common.%s,\n", sourceType))
	b.WriteString(fmt.Sprintf("\t\tCarrierClass:  %q,\n", fw.CarrierClass))
	if len(populatedFrom) > 0 {
		b.WriteString(fmt.Sprintf("\t\tPopulatedFrom: []string{%s},\n", g.formatStringSlice(populatedFrom)))
	}
	b.WriteString(fmt.Sprintf("\t\tTags:          []string{%s},\n", g.formatStringSlice(fw.Tags)))
	b.WriteString("\t},\n")
}

func (g *Generator) writeSymfonyMethodPatternInferred(b *strings.Builder, fw *FrameworkDefinition, m ParsedMethod, sourceType string, populatedFrom []string, description string) {
	classPattern := "^(Symfony\\\\\\\\Component\\\\\\\\HttpFoundation\\\\\\\\)?ParameterBag$"
	id := fmt.Sprintf("%s_parameterbag_%s", fw.Name, m.Name)
	name := fmt.Sprintf("%s ParameterBag->%s()", strings.Title(fw.Name), m.Name)

	b.WriteString("\t{\n")
	b.WriteString(fmt.Sprintf("\t\tID:            %q,\n", id))
	b.WriteString(fmt.Sprintf("\t\tFramework:     %q,\n", fw.Name))
	b.WriteString(fmt.Sprintf("\t\tLanguage:      %q,\n", fw.Language))
	b.WriteString(fmt.Sprintf("\t\tName:          %q,\n", name))
	b.WriteString(fmt.Sprintf("\t\tDescription:   %q,\n", description))
	b.WriteString(fmt.Sprintf("\t\tClassPattern:  %q,\n", classPattern))
	b.WriteString(fmt.Sprintf("\t\tMethodPattern: \"^%s$\",\n", m.Name))
	b.WriteString(fmt.Sprintf("\t\tSourceType:    common.%s,\n", sourceType))
	if len(populatedFrom) > 0 {
		b.WriteString(fmt.Sprintf("\t\tPopulatedFrom: []string{%s},\n", g.formatStringSlice(populatedFrom)))
	}
	b.WriteString(fmt.Sprintf("\t\tTags:          []string{%s},\n", g.formatStringSlice(fw.Tags)))
	b.WriteString("\t},\n")
}

func (g *Generator) writeInit(b *strings.Builder, framework string, fw *FrameworkDefinition) {
	b.WriteString("func init() {\n")
	b.WriteString(fmt.Sprintf("\tRegistry.RegisterAll(%sPatterns)\n\n", framework))
	b.WriteString("\t// Register framework detector\n")
	b.WriteString("\tcommon.RegisterFrameworkDetector(&common.FrameworkDetector{\n")
	b.WriteString(fmt.Sprintf("\t\tFramework:  %q,\n", framework))
	b.WriteString(fmt.Sprintf("\t\tIndicators: []string{%s},\n", g.formatStringSlice(fw.FrameworkDetect)))
	b.WriteString("\t})\n")
	b.WriteString("}\n")
}

func (g *Generator) formatStringSlice(s []string) string {
	quoted := make([]string, len(s))
	for i, v := range s {
		quoted[i] = fmt.Sprintf("%q", v)
	}
	return strings.Join(quoted, ", ")
}
